<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted List]]></title>
    <url>%2F2018%2F08%2F26%2FLeetcode-Reverse%20Linked%20List%2F</url>
    <content type="text"><![CDATA[从排序链表中删除重复元素。Description 解题思路：依次比较相邻的两个链表元素，若值相等，则将前一个节点的next引用为后一个节点的后一个节点。使用cur来依次向下遍历元素，最后返回head。 12345678910111213141516171819# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ cur = head while cur: while cur.next and cur.next.val==cur.val: cur.next = cur.next.next cur = cur.next return head]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine learning]]></title>
    <url>%2F2018%2F08%2F26%2Fmachinelearning%2F</url>
    <content type="text"><![CDATA[本文仅为个人笔记，错误之处敬请包涵。 —— David 这篇介绍不涉及任何公式推导，仅提供一些思路以及相应的资料，感兴趣的可以自行查找资料学习。 书籍推荐理论类： 机器学习，周志华； 统计学习方法，李航； 深度学习，Ian goodfellow; 实践类： 机器学习实战，peter harrington； python机器学习及实践，范淼； 休闲类： 数学之美，吴军； ##博客推荐： 刘建平的博客：https://www.cnblogs.com/pinard/ peghoty的博客：https://blog.csdn.net/itplus poll的笔记：http://www.cnblogs.com/maybe2030/ 监督学习监督学习是指对带标签的数据进行模型学习。 回归回归任务常见的是线性回归linear regression. 注意回归和分类任务的区别，回归的标签值是连续值，而分类的标签值是离散值。 通常我们还会遇到逻辑回归logistic regression, 注意，逻辑回归是用于分类的！ 逻辑回归LR是机器学习中非常基础的算法，因此非常重要。 知识点：交叉熵损失函数，极大似然估计。 相关资料： poll的博客：www.cnblogs.com/maybe2030/p/5494931.html 逻辑回归：https://www.cnblogs.com/Belter/p/6128644.html 逻辑回归推导：http://blog.csdn.net/pakko/article/details/37878837 极大似然估计：http://blog.csdn.net/star_liux/article/details/39666737 SVM通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。 知识点：函数间隔，几何间隔，对偶问题，核函数，软间隔，hinge loss 相关资料： 周志华，机器学习：SVM 图形解释，知乎：https://www.zhihu.com/question/21094489 支持向量机通俗解释，CSDN: http://blog.csdn.net/v_july_v/article/details/7624837 支持向量机通俗导论，july: https://blog.csdn.net/v_july_v/article/details/7624837 KNN给定测试样本，基于某种距离度量找出训练集中与其最靠近的k个训练样本，然后基于这k个邻居的信息来进行预测。K=1时，为最近邻算法。 知识点：k值的选择，距离度量，kd树定义及构建 相关资料： 李航，统计学习，第三章 因子分解机因子分解机主要是考虑了特征之间的关联。 FM主要是为了解决数据稀疏的情况下，（而SVM无法解决稀疏问题），特征怎样组合的问题。 知识点：计算复杂度的推导，梯度计算 相关资料： FM算法详解：https://blog.csdn.net/bitcarmanlee/article/details/52143909 FM计算：https://blog.csdn.net/shenxiaolu1984/article/details/78740481 ###HMM隐马尔可夫模型 隐马模型相对包含内容较多，需要考虑三个基本问题：评估问题，解码问题，和学习问题。 为了更好的理解隐马模型，可以通过http://www.cnblogs.com/skyme/p/4651331.html 这篇文章入门，对隐马模型的隐含状态，可见状态，转换概率等概念有较为清楚的理解。 知识点：评估问题，前向后向算法；解码问题，维特比算法；学习问题，EM算法 相关资料： Cnblog，骰子说明隐马模型：http://www.cnblogs.com/skyme/p/4651331.html 维特比算法说明,及python实现：https://www.cnblogs.com/ylHe/p/6912017.html 数学之美，第5章，隐马模型，BW算法 无监督学习无监督学习是对无标签的数据进行模型学习。 聚类最基本的算法是K-means, 通过不断的迭代得到最终结果。 知识点：K-means的步骤，k值的确定（注意，这里的k和knn中的k概念不同），如何确定k个初始类簇中心点； 频繁项集和关联分析频繁项集主要是指经常出现在一块的物品的集合，关联分析是指从大规模数据中寻找物品间的隐含关系。在寻找频繁项集的过程中，主要有两种算法，Apriori以及FP-growth. 知识点：清楚相关概念：包括项，项集，事务，关联分析，频繁项集，关联规则，支持度，置信度；熟悉Apriori，和FP-growth算法 相关资料： FP-tree算法的实现：https://www.cnblogs.com/zhangchaoyang/articles/2198946.html 序列模式序列模式属于频繁模式的进阶，频繁模式是挖掘事务中的频繁项，序列模式是挖掘频繁的子序列。可以认为，事务是项的无序集合，序列是事务的有序集合。因此，可以和频繁项集对比学习。 知识点：序列的概念，相关算法实现：GSP, SPADE, PrefixSpan,… 相关资料： 数据挖掘关联分析：https://www.cnblogs.com/beaver-sea/p/4743167.html 序列模式，GSP：http://blog.csdn.net/rongyongfeikai2/article/details/40478335 刘建平，PrefixSpan: https://www.cnblogs.com/pinard/p/6323182.html 基本分析一些在机器学习中常用到的基本概念。 梯度下降梯度下降是机器学习中必然掌握的核心概念，需要能够继续推导。为了更好的理解梯度下降，建议从梯度的概念着手。 知识点：梯度下降的概念，批量梯度下降，随机梯度下降，小批量梯度下降（最常用），反向传播 相关资料： Poll的笔记，梯度下降法的三种形式BGD、SGD以及MBGD：https://www.cnblogs.com/maybe2030/p/5089753.html 反向传播，代入数值具体计算：https://www.cnblogs.com/charlotte77/p/5629865.html SGD, BGD, MBGD的比较：https://blog.csdn.net/tsyccnh/article/details/76136771 超参数所谓的模型配置，一般统称为模型的超参数（Hyperparameters），比如KNN算法中的K值，SVM中不同的核函数（Kernal）等。多数情况下，超参数等选择是无限的。在有限的时间内，除了可以验证人工预设几种超参数组合以外，也可以通过启发式的搜索方法对超参数组合进行调优。称这种启发式的超参数搜索方法为网格搜索。 实战中调参即指对超参数的调参。 损失函数损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越小，通常模型的性能越好。 把最大化或者最小化的函数称为目标函数，把需要最小化的函数称为代价函数或者损失函数，因为我们的优化是最小化代价或者损失。 损失函数分为经验风险损失函数和结构风险损失函数。简单来说，结构风险损失函数就是在经验风险损失函数的基础上加上了正则项。 常见损失函数包括：绝对值损失函数，对数损失函数（通常用于分类），平方损失函数（通常用于回归）… 相关资料： 交叉熵：http://blog.csdn.net/sinat_29819401/article/details/58716834 常见的几种损失函数：https://www.cnblogs.com/hejunlin1992/p/8158933.html 知乎，目标函数，损失函数和代价函数的区别：https://www.zhihu.com/question/52398145 算法常用指标分类常见指标包括AUC，ROC，召回率，准确率.. 回归常见指标包括RMSE… 相关资料： poll的笔记：www.cnblogs.com/maybe2030/p/5375175.html AUC，ROC：https://www.jianshu.com/p/c61ae11cc5f6 特征选择和特征抽取在机器学习中特征是非常重要的，经常需要进行特征工程，因此特征选择和特征抽取相当关键。 特征抽取（Feature Extraction）:Creatting a subset of new features by combinations of the exsiting features.也就是说，特征抽取后的新特征是原来特征的一个映射。 特征选择（Feature Selection）:choosing a subset of all the features(the ones more informative)。也就是说，特征选择后的特征是原来特征的一个子集。 特征抽取算法包括PCA，LDA… 特征选择算法包括三类：Filter, Wrapper, and Embedded 知识点：特征选择和特征抽取的意义，PCA, SVD, … 相关资料： csdn博客：http://blog.csdn.net/shenxiaoming77/article/details/50555054 周志华，机器学习，11章：特征选择和稀疏学习 伯乐在线，主成分分析原理详解：http://blog.jobbole.com/109015/ 连续值，异常值，缺失值处理知识点：连续值转换为离散值，异常值检测，缺失值填充 L1和L2正则化知识点：了解正则化的目标，L1和L2正则的作用，等值线图的含义 相关资料： 博客：http://blog.csdn.net/zouxy09/article/details/24971995 L2正则化导致参数较小：https://blog.csdn.net/jinping_shi/article/details/52433975 等值线图形的解释：https://blog.csdn.net/weixin_39845112/article/details/80114918 过拟合过拟合的一些解决方法： 增加样本数据量； 正则化，L1和L2正则； 神经网络中，dropout方法。就是每层网络的训练，随机的让一半神经元不工作。达到防止过拟合的目的。 决策树中可以用剪枝操作 提升方法：early stopping，当训练集合的误差降低，但是验证集合的误差增加时，则停止训练，同时返回具有最小验证集合误差的神经网络； Data augmentation：创建假数据并增加到训练集中 交叉验证训练集training set：用以建立模型，是用来训练模型或确定模型参数的 测试集testing set: 用来评估模型对未知样本进行预测时的精确度，即泛化能力 验证集validation set: 验证集是原始训练集的子集，用来做模型选择 集成学习集成学习在机器学习中有非常重要的地位，因此需要深入的研究。集成学习重要分为三种，Boosting, Bagging 和Stacking。 Boosting包括了GBDT, XGBoost, AdaBoost… Bagging包含了随机森林 GBDTGBDT中的树都是回归树，不是分类树。 每一轮弱学习器的目标是使预测值接近残差， 强学习器的作用是累加前面所有的弱学习器结果，使预测值接近实际值。 残差是上一轮强学习器的预测结果和实际值的差值或者用损失函数的负梯度方向表示。 Gradient Boosting 是GBDT的核心思想，它相比与 Boosting Tree 的主要改进在于: Boosting Tree 对于每一轮基学习器，拟合的是当前模型与标签值的残差 ， GBDT 对于每一轮基学习器，拟合的是当前模型与标签值的残差的负梯度。 知识点：CART回归树，负梯度，GBDT多分类，GBDT与XGBoost的区别 相关资料： 入门介绍：http://blog.csdn.net/w28971023/article/details/8240756 刘建平：https://www.cnblogs.com/pinard/p/6140514.html 集成学习总结：https://xijunlee.github.io/2017/06/03/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/ GBDT和XGBoost比较：https://blog.csdn.net/panda_zjd/article/details/71577463 面试题整理：https://blog.csdn.net/qq_28031525/article/details/70207918 GBDT构建特征：https://blog.csdn.net/shine19930820/article/details/71713680#2-gbdt构建新的特征思想 GBDT与Boosting Tree的区别：https://blog.csdn.net/Liangjun_Feng/article/details/80142724?spm=5176.11104323.5600004.1.444e717dXEDRaI XGBoost是对GBDT的一种改进，也是实战中常用的模型，因此需要加深理解，建议直接看陈天奇大神的论文，以及他的PPT介绍。 知识点：了解XGBoost模型中各个参数的含义 Lightgbm是另一种常见的模型，由微软提出。 知识点：了解Lightgbm中各个参数的含义，了解lightgbm和xgboost的比较 DART将drop out引入到boosting模型中的一种算法。解决over specilization的问题，即初始的第一棵树对整体方向起关键作用，而后续的树一直处于弥补残差的状态，并且只影响一小部分样本，这样后面的树对整体的贡献也在逐渐的弱化。 相关资料： Csdn: https://blog.csdn.net/Yongchun_Zhu/article/details/78745529 AdaBoostadaboost算法的核心思想就是由分类效果较差的弱分类器逐步的强化成一个分类效果较好的强分类器。而强化的过程，就是逐步的改变样本权重，样本权重的高低，代表其在分类器训练过程中的重要程度。 相关资料： 深度剖析adaboost: http://blog.csdn.net/autocyz/article/details/51305999 一问读懂adaboost: www.xtecher.com/Xfeature/view?aid=8109 随机森林和决策树决策树的关键是选择最优划分属性，了解三种划分属性的方式，如ID3, C4.5, GINI。 Random Forest（随机森林）是Bagging的扩展变体，它在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择，因此可以概括RF包括四个部分： 1、随机选择样本（放回抽样）； 2、构建决策树（CART树）； 3、随机选择特征； 4、随机森林投票（平均）。 知识点：决策树划分属性的方式，剪枝，Bootstrapping，随机森林进行特征选择 相关资料： 周志华，机器学习； CART回归树, 李航，第五章决策树； 随机森林，面试：https://blog.csdn.net/qq_28031525/article/details/70207918 特征选择：https://blog.csdn.net/banbuduoyujian/article/details/60328474 stacking在kaggle比赛中常用的一种算法，将训练好的所有基模型对整个训练集进行预测，第j个基模型对第i个训练样本的预测值将作为新的训练集中第i个样本的第j个特征值(预测值变成了特征值），最后基于新的训练集进行训练。 相关资料： 从boosting到stacking: https://baijiahao.baidu.com/s?id=1576971033986792968&amp;wfr=spider&amp;for=pc csdn博客，集成学习总结：https://blog.csdn.net/willduan1/article/details/73618677 stack图形说明：https://www.leiphone.com/news/201709/zYIOJqMzR0mJARzj.html Stacking, kaggle: https://www.kaggle.com/serigne/stacked-regressions-top-4-on-leaderboard 数据处理数据归一化归一化的作用： 归一化后加快了梯度下降求最优解的速度 归一化有可能提高精度 中心化Zero-centered/Mean-substraction： 指变量减去它的均值 标准化Standardization/Normalization 指变量减去均值后（中心化），再除以标准差； 意义：数据中心化和标准化的作用的取消在回归分析中由于不同特征量纲不同或者数值相差较大所引起的误差。 注意：归一化和标准化都是线性变换。 相关资料： 归一化：http://www.cnblogs.com/LBSer/p/4440590.html Batch Normalization数据预处理，相当于深度学习中的数据归一化。 普通机器学习的归一化只针对输入层，而BN针对中间每一层输入进行归一化。 归一化的目的是使的数据的分布集中在激活函数的敏感区域（即中间区域）。 BN层就是对深度学习的中间层的输入数据进行归一化，解决在训练过程中，中间层数据分布发生改变的情况，使得每一层的分布相似，同时保留原来每层训练得到的特征分布（通过变换重构）。 相关资料： Batch normalization 学习笔记：https://blog.csdn.net/hjimce/article/details/50866313 白化 whitening白化就是深度学习里的PCA. 分为PCA白化和ZCA白化。 白化的目的是去除输入数据的冗余信息。假设训练数据是图像，由于图像中相邻像素之间具有很强的相关性，所以用于训练时输入是冗余的； 白化的目的就是降低输入的冗余性。 白化和PCA的关系： PCA如果不降维，而是仅仅使用PCA求出特征向量，然后把数据X映射到新的特征空间，这样的一个映射过程，其实就是满足了我们白化的第一个性质：除去特征之间的相关性。因此白化算法的实现过程，第一步操作就是PCA，求出新特征空间中X的新坐标，然后再对新的坐标进行方差归一化操作。 相关资料： 白化，hjimce: https://blog.csdn.net/hjimce/article/details/50864602 分类不均衡问题分类不均衡问题是指：分类任务中不同类别的训练样例数目差别很大的情况。 对样例数目较多的类别进行欠抽样（undersampling)（1,2,3均是删去多数类样本的方法）： 随机欠采样：最简单的办法是从多数类中随机抽取样本从而减少多数类样本的数量，使数据达到平衡； Edited Nearest Neighbor(ENN): 在多数类的样本中，如果该样本周围的K近邻样本都是少数类，则将该多数类样本删除； Tomek Link Removal:如果有两个不同类别的样本，它们的最近邻都是对方，那么A,B就是Tomek link。我们要做的就是将所有Tomek link都删除掉，即将组成Tomek link的两个样本，如果有一个属于多数类样本，就将该多数类样本删除掉。 代表性算法EasyEnsemble,利用集成学习机制，将该类别划分为若干个集合供不同学习器使用，对于每个学习器来说都是欠采样，但从全局来看却不会丢失重要信息。 对样例数目较少的类别进行过抽样（oversampling)： 过抽样不是简单的对样本进行重复抽样，否则会招致严重的过拟合，过采样的代表算法是SMOTE,基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中。简单来说，人工合成的样本是每个少数类样本与其K近邻的连线上的点。 再缩放（再平衡）技术 即给少数类较多的权重，而给多数类更少的权重，使得少数类判别错误的损失大于多数类判别错误的损失，其中，缩放因子为类别样例数目的比值 相关资料： SMOTE算法：https://blog.csdn.net/jiede1/article/details/70215477 分类不均衡：https://blog.csdn.net/ly_ysys629/article/details/72846200 分类不均衡方法综述: http://lib.csdn.net/article/machinelearning/41294]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hexo 更新hexo clean hexo g -d]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
